<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Realtime Transcript Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .row { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
    button { padding: 10px 16px; border: 0; border-radius: 10px; cursor: pointer; }
    button.primary { background: #2563eb; color: white; }
    button.secondary { background: #e5e7eb; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #vu { width: 240px; height: 10px; background: #eee; border-radius: 8px; overflow: hidden; }
    #bar { height: 100%; width: 0%; background: #16a34a; transition: width .05s linear; }
    #status { font-size: 14px; color: #6b7280; }
    #transcript { width: 100%; min-height: 220px; padding: 12px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fafafa; line-height: 1.65; }
    #fullTranscriptText { white-space: pre-line;}
    label { font-size: 14px; color: #374151; }
    select, input[type="text"] { padding: 8px 10px; border-radius: 8px; border: 1px solid #e5e7eb; }
    .tag { display: inline-block; padding: 4px 8px; background: #eef2ff; color: #3730a3; border-radius: 999px; font-size: 12px; }
    .toggle-group { display: flex; align-items: center; gap: 8px; }
    .max-speaker-container { display: none; align-items: center; gap: 8px; }
    .max-speaker-container input { width: 80px; }
    .segment-speaker { font-weight: 600; color: #1f2937; margin-right: 6px; }
    .switch { position: relative; display: inline-block; width: 46px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #d1d5db; transition: .3s; border-radius: 999px; }
    .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.2); }
    .switch input:checked + .slider { background-color: #2563eb; }
    .switch input:focus + .slider { box-shadow: 0 0 1px #2563eb; }
    .switch input:checked + .slider:before { transform: translateX(22px); }
    #notificationContainer { position: fixed; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 12px; z-index: 9999; }
    .notification { min-width: 240px; padding: 12px 16px; border-radius: 8px; background: #1f2937; color: white; box-shadow: 0 10px 25px rgba(15, 23, 42, 0.2); font-size: 14px; line-height: 1.4; opacity: 0.95; transition: opacity 0.3s ease; cursor: pointer; }
    .notification.error { background: #dc2626; }
    .notification.success { background: #16a34a; }
    .notification.info { background: #2563eb; }
    .notification.fade-out { opacity: 0; }
    
    /* Tabs */
    .tabs { display: flex; gap: 8px; margin-bottom: 24px; border-bottom: 2px solid #e5e7eb; }
    .tab { padding: 12px 20px; cursor: pointer; border: none; background: none; font-size: 16px; color: #6b7280; }
    .tab.active { color: #2563eb; border-bottom: 2px solid #2563eb; margin-bottom: -2px; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* File upload */
    .upload-area { border: 2px dashed #d1d5db; border-radius: 12px; padding: 40px; text-align: center; margin-bottom: 20px; background: #f9fafb; }
    .upload-area.dragover { border-color: #2563eb; background: #eff6ff; }
    .upload-area input[type="file"] { display: none; }
    .progress { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; overflow: hidden; margin: 12px 0; }
    .progress-bar { height: 100%; background: #2563eb; width: 0%; transition: width 0.3s; }
    .file-result { margin-top: 20px; }
    .segment-item { margin: 8px 0; padding: 8px; background: #f9fafb; border-left: 3px solid #2563eb; border-radius: 4px; }
    .segment-time { font-size: 12px; color: #6b7280; margin-right: 8px; }
  </style>
</head>
<body>
  <h1>üéôÔ∏è Realtime Transcript</h1>
  <div id="notificationContainer"></div>
  
  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" data-tab="realtime">Realtime</button>
    <button class="tab" data-tab="upload">Upload File</button>
  </div>

  <!-- Realtime Tab -->
  <div id="realtime-tab" class="tab-content active">
    <div class="row">
      <label>WebSocket URL:</label>
      <input id="wsUrl" type="text" value="" style="width: 360px;" placeholder="T·ª± ƒë·ªông detect t·ª´ backend...">
      <span class="tag">PCM16 @ 16kHz</span>
    </div>

    <div class="row">
      <label>Ng√¥n ng·ªØ (g·ª£i √Ω):</label>
      <select id="lang">
        <option value="auto" selected>T·ª± ƒë·ªông</option>
        <option value="vi">Ti·∫øng Vi·ªát</option>
        <option value="en">English</option>
        <option value="ja">Êó•Êú¨Ë™û</option>
      </select>

      <button id="startBtn" class="primary">Start</button>
      <button id="stopBtn" class="secondary" disabled>Stop</button>
      <span id="status">Ch∆∞a k·∫øt n·ªëi</span>
    </div>

    <div class="row">
      <div class="toggle-group">
        <label>Detect speaker:</label>
        <label class="switch" aria-label="Detect speaker">
          <input type="checkbox" id="detectSpeakerToggle">
          <span class="slider"></span>
        </label>
      </div>
      <div id="maxSpeakersContainer" class="max-speaker-container">
        <label for="maxSpeakersInput">Max speaker:</label>
        <input type="number" id="maxSpeakersInput" min="1" value="2">
      </div>
    </div>

    <div class="row">
      <div id="vu"><div id="bar"></div></div>
      <span id="levelText">0%</span>
    </div>

    <p id="realtimeLanguageContainer" style="display: none;"><strong>Ng√¥n ng·ªØ ph√°t hi·ªán:</strong><span id="realtimeLanguage"></span></p>

    <div id="realtimeFullTranscript" style="margin-top: 20px; display: none;">
      <h4>Full Transcript:</h4>
      <div id="fullTranscriptText" style="background: #f9fafb; padding: 16px; border-radius: 8px; margin: 12px 0; white-space: pre-wrap; line-height: 1.6; min-height: 100px; max-height: 300px; overflow-y: auto;"></div>
    </div>

    <div id="realtimeSegments" style="margin-top: 20px; display: none;">
      <h4>Segments (c√≥ timestamp):</h4>
      <div id="segmentsList" style="max-height: 400px; overflow-y: auto;"></div>
    </div>
  </div>

  <!-- Upload File Tab -->
  <div id="upload-tab" class="tab-content">
    <div class="row">
      <label>Ng√¥n ng·ªØ (g·ª£i √Ω):</label>
      <select id="fileLang">
        <option value="auto" selected>T·ª± ƒë·ªông</option>
        <option value="vi">Ti·∫øng Vi·ªát</option>
        <option value="en">English</option>
        <option value="ja">Êó•Êú¨Ë™û</option>
      </select>
      <span id="fileStatus">S·∫µn s√†ng upload</span>
    </div>

    <div class="row">
      <div class="toggle-group">
        <label>Detect speaker:</label>
        <label class="switch" aria-label="Detect speaker for upload">
          <input type="checkbox" id="detectSpeakerUploadToggle">
          <span class="slider"></span>
        </label>
      </div>
      <div id="uploadMaxSpeakersContainer" class="max-speaker-container">
        <label for="maxSpeakersUploadInput">Max speaker:</label>
        <input type="number" id="maxSpeakersUploadInput" min="1" value="2">
      </div>
    </div>

    <div class="upload-area" id="uploadArea">
      <p style="font-size: 18px; margin-bottom: 12px;">üìÅ K√©o th·∫£ file v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn</p>
      <p style="font-size: 14px; color: #6b7280;">H·ªó tr·ª£: .mp3, .wav, .m4a, .mp4, .avi, .mov, ...</p>
      <input type="file" id="fileInput" accept="audio/*,video/*">
      <button class="primary" id="selectFileBtn" style="margin-top: 12px;">Ch·ªçn File</button>
    </div>

    <div class="progress" id="progressContainer" style="display: none;">
      <div class="progress-bar" id="progressBar"></div>
    </div>

    <div id="fileResult" class="file-result"></div>
  </div>

  <script>
    // ====== T·ª± ƒë·ªông detect WebSocket URL t·ª´ backend port ======
    function getWebSocketUrl() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const hostname = window.location.hostname;
      let port = window.location.port;
      
      // N·∫øu kh√¥ng c√≥ port trong URL (default port), kh√¥ng th√™m port v√†o WebSocket URL
      // V√¨ WebSocket s·∫Ω t·ª± ƒë·ªông d√πng default port (80 cho ws, 443 cho wss)
      if (!port || port === '') {
        return `${protocol}//${hostname}/ws`;
      }
      
      return `${protocol}//${hostname}:${port}/ws`;
    }

    // Set WebSocket URL m·∫∑c ƒë·ªãnh khi page load
    window.addEventListener('DOMContentLoaded', () => {
      const wsUrlEl = document.getElementById("wsUrl");
      if (wsUrlEl) {
        // Ch·ªâ set n·∫øu ch∆∞a c√≥ gi√° tr·ªã ho·∫∑c l√† gi√° tr·ªã m·∫∑c ƒë·ªãnh c≈©
        if (!wsUrlEl.value || wsUrlEl.value === "ws://localhost:8917/ws") {
          wsUrlEl.value = getWebSocketUrl();
        }
      }
    });

    function showNotification(message, type = "info", duration = 5000) {
      const container = document.getElementById("notificationContainer");
      if (!container || !message) return;

      const note = document.createElement("div");
      note.className = `notification ${type}`;
      note.textContent = message;
      container.appendChild(note);

      const remove = () => {
        note.classList.add("fade-out");
        setTimeout(() => {
          if (note.parentNode) {
            note.parentNode.removeChild(note);
          }
        }, 300);
      };

      note.addEventListener("click", remove);
      setTimeout(remove, duration);
    }

    function setupSpeakerToggle(toggle, container, input) {
      if (!toggle || !container) return;
      const updateVisibility = () => {
        container.style.display = toggle.checked ? "flex" : "none";
        if (toggle.checked && input) {
          if (!input.value || Number(input.value) <= 0) {
            input.value = 2;
          }
        }
      };
      toggle.addEventListener("change", updateVisibility);
      updateVisibility();
    }

    function setRealtimeConfigDisabled(disabled) {
      if (wsUrlEl) wsUrlEl.disabled = disabled;
      if (langEl) langEl.disabled = disabled;
      if (detectSpeakerToggle) detectSpeakerToggle.disabled = disabled;
      if (maxSpeakersInput) maxSpeakersInput.disabled = disabled;
    }

    function setUploadConfigDisabled(disabled) {
      const selectFileBtn = document.getElementById("selectFileBtn");
      if (fileLang) fileLang.disabled = disabled;
      if (detectSpeakerUploadToggle) detectSpeakerUploadToggle.disabled = disabled;
      if (maxSpeakersUploadInput) maxSpeakersUploadInput.disabled = disabled;
      if (selectFileBtn) selectFileBtn.disabled = disabled;
      if (fileInput) fileInput.disabled = disabled;
      // Optional: visually indicate disabled upload area
      if (uploadArea) uploadArea.style.pointerEvents = disabled ? "none" : "auto";
      if (uploadArea) uploadArea.style.opacity = disabled ? "0.7" : "1";
    }

    // ====== Audio capture + downsample (to 16kHz mono) + PCM16LE ======
    let audioCtx, micStream, sourceNode, processorNode;
    let ws;
    let running = false;
    let awaitingFinal = false;
    let stopFinalized = false;
    let finalTimeoutId = null;

    function clearFinalTimeout() {
      if (finalTimeoutId) {
        clearTimeout(finalTimeoutId);
        finalTimeoutId = null;
      }
    }

    async function releaseAudioResources() {
      try {
        if (processorNode) {
          processorNode.disconnect();
        }
      } catch (e) {}
      processorNode = null;

      try {
        if (sourceNode) {
          sourceNode.disconnect();
        }
      } catch (e) {}
      sourceNode = null;

      if (audioCtx) {
        try {
          if (audioCtx.state !== "closed") {
            await audioCtx.close();
          }
        } catch (e) {}
      }
      audioCtx = null;

      if (micStream) {
        try {
          micStream.getTracks().forEach(t => t.stop());
        } catch (e) {}
      }
      micStream = null;
    }

    function resetStopState() {
      clearFinalTimeout();
      awaitingFinal = false;
      stopFinalized = false;
    }

    function finalizeStop({ statusMessage, statusGood = false, silent = false } = {}) {
      if (stopFinalized) return;

      stopFinalized = true;
      awaitingFinal = false;
      clearFinalTimeout();

      releaseAudioResources().catch(() => {});

      const socket = ws;
      if (socket && socket.readyState === WebSocket.OPEN) {
        try {
          socket.close();
        } catch (e) {}
      }
      ws = null;

      startBtn.disabled = false;
      stopBtn.disabled = true;
      running = false;
      setRealtimeConfigDisabled(false);

      if (!silent && statusMessage) {
        updateStatus(statusMessage, statusGood);
      }
    }

    const startBtn = document.getElementById("startBtn");
    const stopBtn  = document.getElementById("stopBtn");
    const statusEl = document.getElementById("status");
    const wsUrlEl  = document.getElementById("wsUrl");
    const langEl   = document.getElementById("lang");
    const fullTranscriptEl = document.getElementById("fullTranscriptText");
    const segmentsListEl = document.getElementById("segmentsList");
    const barEl = document.getElementById("bar");
    const levelTextEl = document.getElementById("levelText");
    const realtimeLanguageEl = document.getElementById("realtimeLanguage");
    const realtimeLanguageContainer = document.getElementById("realtimeLanguageContainer");
    const realtimeFullTranscript = document.getElementById("realtimeFullTranscript");
    const realtimeSegments = document.getElementById("realtimeSegments");
    const detectSpeakerToggle = document.getElementById("detectSpeakerToggle");
    const maxSpeakersContainer = document.getElementById("maxSpeakersContainer");
    const maxSpeakersInput = document.getElementById("maxSpeakersInput");

    // Buffer ƒë·ªÉ gom d·ªØ li·ªáu tr∆∞·ªõc khi resample
    // G·ª≠i frame c·ª° 40ms ƒë·ªÉ latency th·∫•p (~640 samples @ 16kHz -> 1280 bytes)
    const TARGET_SR = 16000;
    const FRAME_MS = 40;

    let inputSampleRate = 48000;
    let leftover = new Float32Array(0);
    let currentPartialText = ""; // Track partial text t·ª´ l·∫ßn full cu·ªëi c√πng
    let partialStartIndex = 0; // V·ªã tr√≠ b·∫Øt ƒë·∫ßu c·ªßa partial text trong fullTranscriptEl

    function updateStatus(t, good=true) {
      statusEl.textContent = t;
      statusEl.style.color = good ? "#16a34a" : "#dc2626";
    }

    function levelMeter(float32) {
      if (!float32 || float32.length === 0) return 0;
      // RMS ƒë∆°n gi·∫£n
      let sum = 0;
      for (let i=0; i<float32.length; i++) {
        const v = float32[i];
        sum += v*v;
      }
      const rms = Math.sqrt(sum / float32.length);
      const pct = Math.min(100, Math.max(0, Math.round(rms * 200))); // scale
      barEl.style.width = pct + "%";
      levelTextEl.textContent = pct + "%";
    }

    function downsampleFloat32To16kHz(float32, inSampleRate) {
      if (inSampleRate === TARGET_SR) return float32;
      const ratio = inSampleRate / TARGET_SR;
      const outLength = Math.round(float32.length / ratio);
      const out = new Float32Array(outLength);
      let pos = 0;
      let idx = 0;
      while (pos < outLength) {
        // simple linear interpolation
        const i = idx | 0;
        const frac = idx - i;
        const s0 = float32[i] || 0;
        const s1 = float32[i+1] || s0;
        out[pos++] = s0 + (s1 - s0) * frac;
        idx += ratio;
      }
      return out;
    }

    function float32ToPCM16(float32) {
      const out = new Int16Array(float32.length);
      for (let i=0; i<float32.length; i++) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
      }
      return out;
    }

    function handleAudioProcess(e) {
      if (!running) return;
      const input = e.inputBuffer.getChannelData(0); // mono
      // N·ªëi leftover
      const merged = new Float32Array(leftover.length + input.length);
      merged.set(leftover, 0);
      merged.set(input, leftover.length);

      // Downsample v·ªÅ 16k
      const ds = downsampleFloat32To16kHz(merged, inputSampleRate);
      levelMeter(ds);

      // T√≠nh s·ªë samples cho m·ªôt frame g·ª≠i
      const frameSamples = Math.round(TARGET_SR * (FRAME_MS / 1000));
      const framesCount = Math.floor(ds.length / frameSamples);

      for (let i=0; i<framesCount; i++) {
        const frame = ds.subarray(i*frameSamples, (i+1)*frameSamples);
        const pcm16 = float32ToPCM16(frame);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(pcm16.buffer);
        }
      }

      // leftover ph·∫ßn d∆∞ sau khi t√°ch frame
      const leftoverStart = framesCount * frameSamples;
      leftover = ds.slice(leftoverStart);
    }

    async function start() {
      if (running) return;
      resetStopState();
      fullTranscriptEl.textContent = "";  // Clear full transcript
      segmentsListEl.innerHTML = "";     // Clear segments list
      realtimeLanguageEl.textContent = ""; // Clear realtime language
      leftover = new Float32Array(0);
      currentPartialText = ""; // Reset partial text tracking
      partialStartIndex = 0; // Reset partial start index

      // Disable realtime configs while running
      setRealtimeConfigDisabled(true);

      const detectSpeakerEnabled = detectSpeakerToggle ? detectSpeakerToggle.checked : false;
      let maxSpeakersValue = 2;
      if (detectSpeakerEnabled && maxSpeakersInput) {
        const parsed = parseInt(maxSpeakersInput.value, 10);
        if (!Number.isNaN(parsed) && parsed > 0) {
          maxSpeakersValue = parsed;
        }
      }

      // Hi·ªÉn th·ªã c√°c ph·∫ßn t·ª≠ khi b·∫Øt ƒë·∫ßu
      realtimeLanguageContainer.style.display = "block";
      realtimeFullTranscript.style.display = "block";
      realtimeSegments.style.display = "block";

      ws = new WebSocket(wsUrlEl.value);
      ws.binaryType = "arraybuffer";

      ws.onopen = () => {
        updateStatus("ƒê√£ k·∫øt n·ªëi", true);
        const startPayload = {
          event: "start",
          sample_rate: TARGET_SR,
          format: "pcm16",
          language: langEl.value || "auto",
          detect_speaker: detectSpeakerEnabled,
        };
        if (detectSpeakerEnabled) {
          startPayload.max_speakers = maxSpeakersValue;
        }
        ws.send(JSON.stringify(startPayload));
      };

      ws.onmessage = async (evt) => {
        try {
          const data = JSON.parse(evt.data);
          if (data.type === "ready") {
            updateStatus("S·∫µn s√†ng, ƒëang ghi...");
          } else if (data.type === "partial") {
            // Stream v√†o Full Transcript
            if (data.text && data.text.trim()) {
              // Fallback: n·∫øu kh√¥ng c√≥ segments, append text v·ªõi space
              const currentText = fullTranscriptEl.textContent;
              let textToAdd = data.text.trim();
              
              if (currentText) {
                console.log("data.text: ", textToAdd);
                if (textToAdd.startsWith("/newline")) {
                    textToAdd = "\n" + textToAdd.replace("/newline", "");
                    fullTranscriptEl.textContent = currentText + textToAdd;
                    // Khi c√≥ /newline, ƒë√¢y l√† b·∫Øt ƒë·∫ßu c·ªßa m·ªôt ƒëo·∫°n partial m·ªõi
                    // L∆∞u v·ªã tr√≠ b·∫Øt ƒë·∫ßu (sau \n, t·ª©c l√† sau currentText + 1)
                    partialStartIndex = currentText.length + 1; // +1 ƒë·ªÉ b·ªè qua \n
                    currentPartialText = textToAdd.substring(1); // B·ªè \n ƒë·∫ßu ti√™n
                } else {
                  fullTranscriptEl.textContent = currentText + textToAdd;
                  // N·∫øu ch∆∞a c√≥ partialStartIndex (l·∫ßn ƒë·∫ßu), ƒë·∫∑t n√≥
                  if (partialStartIndex === 0 && currentPartialText === "") {
                    partialStartIndex = currentText.length;
                  }
                  currentPartialText += textToAdd;
                }
              } else {
                textToAdd = textToAdd.replace("/newline", "");
                fullTranscriptEl.textContent = textToAdd;
                partialStartIndex = 0; // B·∫Øt ƒë·∫ßu t·ª´ ƒë·∫ßu
                currentPartialText = textToAdd;
              }
              
              if (data.language && data.language !== "ja") {
                fullTranscriptEl.textContent += " "
                currentPartialText += " ";
              }
              realtimeLanguageEl.textContent = " " + data.language + " (" + (data.language_probability * 100).toFixed(1) + "%)";
              fullTranscriptEl.scrollTop = fullTranscriptEl.scrollHeight;
            }

            // Stream v√†o Segments
            if (data.segments && data.segments.length > 0) {
              data.segments.forEach(seg => {
                const timeStr = `${formatTime(seg.start)} ‚Üí ${formatTime(seg.end)}`;
                const segmentDiv = document.createElement("div");
                segmentDiv.className = "segment-item";
                segmentDiv.style.margin = "8px 0";
                const timeSpan = document.createElement("span");
                timeSpan.className = "segment-time";
                timeSpan.textContent = timeStr;
                const textSpan = document.createElement("span");
                if (seg.speaker_id) {
                  const speakerSpan = document.createElement("span");
                  speakerSpan.className = "segment-speaker";
                  speakerSpan.textContent = `${seg.speaker_id}:`;
                  textSpan.appendChild(speakerSpan);
                  const textContent = seg.text || "";
                  textSpan.appendChild(document.createTextNode(textContent ? ` ${textContent}` : ""));
                } else {
                  textSpan.textContent = seg.text || "";
                }
                segmentDiv.appendChild(timeSpan);
                segmentDiv.appendChild(textSpan);
                segmentsListEl.appendChild(segmentDiv);
                // Auto scroll
                segmentsListEl.scrollTop = segmentsListEl.scrollHeight;
              });
            }
          } else if (data.type === "full") {
            // Thay th·∫ø ph·∫ßn partial t∆∞∆°ng ·ª©ng b·∫±ng full text, gi·ªØ l·∫°i c√°c full text tr∆∞·ªõc ƒë√≥
            const fullText = data.text.replace("/newline", "\n");
            const currentFullText = fullTranscriptEl.textContent;
            
            if (partialStartIndex >= 0 && partialStartIndex < currentFullText.length) {
              // Thay th·∫ø t·ª´ partialStartIndex ƒë·∫øn cu·ªëi b·∫±ng fullText
              const beforePartial = currentFullText.substring(0, partialStartIndex);
              fullTranscriptEl.textContent = beforePartial + fullText;
            } else {
              // Fallback: n·∫øu partialStartIndex kh√¥ng h·ª£p l·ªá, append v√†o cu·ªëi
              if (currentFullText) {
                fullTranscriptEl.textContent = currentFullText + (currentFullText.endsWith("\n") ? "" : "\n") + fullText;
              } else {
                fullTranscriptEl.textContent = fullText;
              }
            }
            
            // Reset tracking sau khi ƒë√£ thay th·∫ø
            currentPartialText = "";
            partialStartIndex = fullTranscriptEl.textContent.length; // ƒê·∫∑t l·∫°i cho l·∫ßn partial ti·∫øp theo
            
            realtimeLanguageEl.textContent = " " + data.language + " (" + (data.language_probability * 100).toFixed(1) + "%)";
            fullTranscriptEl.scrollTop = fullTranscriptEl.scrollHeight;
          }
          else if (data.type === "final") {
            updateStatus("K·∫øt th√∫c phi√™n", true);
            finalizeStop({ silent: true });
          } else if (data.type === "error") {
            updateStatus("L·ªói: " + data.message, false);
            showNotification(data.message || "C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω.", "error");
            await stop({ silent: true, force: true });
          }
        } catch (e) {
          // ignore non-JSON (n·∫øu c√≥)
        }
      };

      ws.onclose = () => {
        if (!stopFinalized) {
          finalizeStop({
            statusMessage: awaitingFinal ? "ƒê√£ d·ª´ng (server ƒë√≥ng k·∫øt n·ªëi)" : "ƒê√£ ng·∫Øt k·∫øt n·ªëi",
            statusGood: false,
          });
        }
      };

      // L·∫•y micro
      const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true }, video: false });
      micStream = stream;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      inputSampleRate = audioCtx.sampleRate; // th∆∞·ªùng l√† 48000
      sourceNode = audioCtx.createMediaStreamSource(stream);

      // ScriptProcessor cho demo (AudioWorklet chu·∫©n h∆°n, nh∆∞ng d√†i h∆°n)
      processorNode = audioCtx.createScriptProcessor(4096, 1, 1);
      processorNode.onaudioprocess = handleAudioProcess;

      sourceNode.connect(processorNode);
      processorNode.connect(audioCtx.destination);

      startBtn.disabled = true;
      stopBtn.disabled = false;
      running = true;
    }

    async function stop(arg) {
      const isEvent = arg && typeof arg.preventDefault === "function";
      if (isEvent && arg.type !== "beforeunload") {
        arg.preventDefault();
      }
      const options = isEvent ? {} : (arg || {});
      const { silent = false, force = false } = options;
      const shouldAwaitFinal = !force;

      if (!running) {
        if (shouldAwaitFinal) {
          if (awaitingFinal && !silent) {
            updateStatus("ƒêang ch·ªù server k·∫øt th√∫c...", true);
          }
          return;
        }
      }

      if (awaitingFinal && shouldAwaitFinal) {
        if (!silent) {
          updateStatus("ƒêang ch·ªù server k·∫øt th√∫c...", true);
        }
        return;
      }

      startBtn.disabled = true;
      stopBtn.disabled = true;

      if (shouldAwaitFinal) {
        awaitingFinal = true;
        stopFinalized = false;
        if (!silent) {
          updateStatus("ƒêang d·ª´ng, ch·ªù server...", true);
        }
      }

      if (ws && ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(JSON.stringify({ event: "stop" }));
        } catch (e) {}
      }

      await releaseAudioResources();

      running = false;

      if (shouldAwaitFinal) {
        clearFinalTimeout();
        finalTimeoutId = setTimeout(() => {
          finalizeStop({
            statusMessage: "ƒê√£ d·ª´ng (h·∫øt th·ªùi gian ch·ªù server)",
            statusGood: false,
          });
        }, 5000);
        return;
      }

      finalizeStop({
        statusMessage: silent ? undefined : "ƒê√£ d·ª´ng",
        statusGood: false,
        silent,
      });
    }

    startBtn.addEventListener("click", start);
    stopBtn .addEventListener("click", stop);

    // D·ªçn d·∫πp khi ƒë√≥ng tab
    window.addEventListener("beforeunload", stop);

    // ====== Tabs ======
    document.querySelectorAll(".tab").forEach(tab => {
      tab.addEventListener("click", () => {
        const tabName = tab.dataset.tab;
        // Update active tab
        document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        // Update active content
        document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
        document.getElementById(`${tabName}-tab`).classList.add("active");
      });
    });

    // ====== File Upload ======
    const fileInput = document.getElementById("fileInput");
    const uploadArea = document.getElementById("uploadArea");
    const fileStatus = document.getElementById("fileStatus");
    const fileResult = document.getElementById("fileResult");
    const progressContainer = document.getElementById("progressContainer");
    const progressBar = document.getElementById("progressBar");
    const fileLang = document.getElementById("fileLang");
    const detectSpeakerUploadToggle = document.getElementById("detectSpeakerUploadToggle");
    const uploadMaxSpeakersContainer = document.getElementById("uploadMaxSpeakersContainer");
    const maxSpeakersUploadInput = document.getElementById("maxSpeakersUploadInput");

    setupSpeakerToggle(detectSpeakerToggle, maxSpeakersContainer, maxSpeakersInput);
    setupSpeakerToggle(detectSpeakerUploadToggle, uploadMaxSpeakersContainer, maxSpeakersUploadInput);

    // Drag and drop
    uploadArea.addEventListener("dragover", (e) => {
      e.preventDefault();
      uploadArea.classList.add("dragover");
    });

    uploadArea.addEventListener("dragleave", () => {
      uploadArea.classList.remove("dragover");
    });

    uploadArea.addEventListener("drop", (e) => {
      e.preventDefault();
      uploadArea.classList.remove("dragover");
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        fileInput.files = files;
        handleFileUpload(files[0]);
      }
    });

    // Button ri√™ng ƒë·ªÉ ch·ªçn file
    const selectFileBtn = document.getElementById("selectFileBtn");
    selectFileBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      fileInput.click();
    });

    // Click v√†o upload area (ngo√†i button) c≈©ng m·ªü dialog
    uploadArea.addEventListener("click", (e) => {
      // Ch·ªâ m·ªü dialog n·∫øu click v√†o area, kh√¥ng ph·∫£i button
      if (e.target === uploadArea || (e.target.tagName !== "BUTTON" && !e.target.closest("button"))) {
        fileInput.click();
      }
    });

    fileInput.addEventListener("change", (e) => {
      if (e.target.files.length > 0) {
        handleFileUpload(e.target.files[0]);
      }
    });

    async function handleFileUpload(file) {
      // If upload UI is disabled, ignore accidental triggers
      if (fileInput && fileInput.disabled) return;

      const handleUploadError = (message) => {
        fileStatus.textContent = `L·ªói: ${message}`;
        fileStatus.style.color = "#dc2626";
        fileResult.innerHTML = `<p style="color: #dc2626;">L·ªói: ${message}</p>`;
        progressContainer.style.display = "none";
        fileInput.value = "";
        showNotification(message, "error");
        setUploadConfigDisabled(false);
      };

      fileResult.innerHTML = "";
      fileStatus.textContent = `ƒêang x·ª≠ l√Ω: ${file.name}...`;
      fileStatus.style.color = "#6b7280";
      progressContainer.style.display = "block";
      progressBar.style.width = "0%";

      // Disable upload configs while processing
      setUploadConfigDisabled(true);

      const formData = new FormData();
      formData.append("file", file);
      const lang = fileLang.value;
      if (lang && lang !== "auto") {
        formData.append("language", lang);
      }
      const detectSpeakerForUpload = detectSpeakerUploadToggle ? detectSpeakerUploadToggle.checked : false;
      formData.append("detect_speaker", detectSpeakerForUpload ? "true" : "false");
      if (detectSpeakerForUpload) {
        let uploadMaxSpeakers = 2;
        if (maxSpeakersUploadInput) {
          const parsed = parseInt(maxSpeakersUploadInput.value, 10);
          if (!Number.isNaN(parsed) && parsed > 0) {
            uploadMaxSpeakers = parsed;
          }
        }
        formData.append("max_speakers", String(uploadMaxSpeakers));
      }

      try {
        const xhr = new XMLHttpRequest();
        
        xhr.upload.addEventListener("progress", (e) => {
          if (e.lengthComputable) {
            const percent = Math.round((e.loaded / e.total) * 100);
            progressBar.style.width = percent + "%";
          }
        });

        xhr.addEventListener("load", () => {
          progressBar.style.width = "100%";
          if (xhr.status === 200) {
            let result;
            try {
              result = JSON.parse(xhr.responseText);
            } catch (parseError) {
              handleUploadError("Ph·∫£n h·ªìi t·ª´ server kh√¥ng h·ª£p l·ªá.");
              return;
            }

            if (result.success) {
              displayResult(result);
              fileStatus.textContent = `Ho√†n th√†nh: ${file.name}`;
              fileStatus.style.color = "#16a34a";
              
              // T·∫°o notification message v·ªõi RTF n·∫øu c√≥
              let notificationMsg = `X·ª≠ l√Ω th√†nh c√¥ng: ${file.name}`;
              if (result.rtf !== null && result.rtf !== undefined) {
                const rtfValue = typeof result.rtf === 'number' ? result.rtf.toFixed(3) : result.rtf;
                const rtfStatus = result.rtf < 1.0 ? '‚ö°' : (result.rtf <= 1.0 ? '‚úì' : '‚ö†Ô∏è');
                notificationMsg += ` (RTF: ${rtfValue} ${rtfStatus})`;
              }
              showNotification(notificationMsg, "success");
            } else {
              handleUploadError(result.error || "Server tr·∫£ v·ªÅ l·ªói.");
            }
          } else {
            handleUploadError(`HTTP ${xhr.status}: ${xhr.statusText || "Unknown status"}`);
          }
        });

        xhr.addEventListener("error", () => {
          handleUploadError("Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi server.");
        });

        xhr.addEventListener("loadend", () => {
          // Reset file input ƒë·ªÉ c√≥ th·ªÉ upload l·∫°i c√πng file
          fileInput.value = "";
          // Re-enable upload configs after completion
          setUploadConfigDisabled(false);
        });

        // G·ª≠i request
        xhr.open("POST", "/api/transcribe");
        xhr.send(formData);

      } catch (error) {
        handleUploadError(error.message || "C√≥ l·ªói kh√¥ng x√°c ƒë·ªãnh x·∫£y ra.");
      }
    }

    function displayResult(result) {
      let html = `<h3>üìÑ ${result.filename}</h3>`;
      
      if (result.language) {
        html += `<p><strong>Ng√¥n ng·ªØ ph√°t hi·ªán:</strong> ${result.language} (${(result.language_probability * 100).toFixed(1)}%)</p>`;
      }

      html += `<h4>Full Transcript:</h4>`;
      html += `<div style="background: #f9fafb; padding: 16px; border-radius: 8px; margin: 12px 0; white-space: pre-wrap; line-height: 1.6;">${result.text || result.full_text || "Kh√¥ng c√≥ transcript"}</div>`;

      if (result.segments && result.segments.length > 0) {
        html += `<h4>Segments (c√≥ timestamp):</h4>`;
        result.segments.forEach(seg => {
          const timeStr = `${formatTime(seg.start)} ‚Üí ${formatTime(seg.end)}`;
          const speakerPrefix = seg.speaker_id ? `<span class="segment-speaker">${seg.speaker_id}:</span> ` : "";
          html += `<div class="segment-item">
            <span class="segment-time">${timeStr}</span>
            <span>${speakerPrefix}${seg.text}</span>
          </div>`;
        });
      }

      fileResult.innerHTML = html;
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const ms = Math.floor((seconds % 1) * 100);
      return `${mins}:${secs.toString().padStart(2, "0")}.${ms.toString().padStart(2, "0")}`;
    }
  </script>
</body>
</html>

